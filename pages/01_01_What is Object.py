import streamlit as st

st.title('オブジェクトについて知る')

st.header('1. オブジェクトとは')
st.write('''
Hello Worldとは，プログラミング言語の世界における伝統的な初歩的なプログラムです．多くのPython入門者はまずインタプリタを起動し次のように入力することで，この世界に足を踏み入れてきたはずです．
''')

st.code('''\
>>> 'Hello World'
'Hello World'
''')

st.write('''\
一見すると（echo コマンドのように）インタプリタが呼応して`'Hello World'`という文字列を返しているだけのように見えます．

しかし事態はそう単純な話ではありません．この裏側でインタプリタは、`'Hello World'`という値をもつ文字列型のオブジェクトを生成した後，そのオブジェクトの文字列表現を標準出力しており，我々はその結果を目にしています．
''')

st.write('''\
Pythonでは、**全ての**要素がオブジェクトとして表現されます．上でみた文字列や整数，浮動小数点数，リスト，辞書，関数，クラス，例外，モジュールなどなど全てがオブジェクトです．
''')

st.write('''\
オブジェクトとは**値(value)と型(type)，識別子(id)を持つ透明な箱**のようなものです．

透明であるため，我々は自由に箱の中身を覗くことができます．
''')

st.text('''\
---------------
|             |
|             |
|    value    |
|             |
| type        |
---------------
''')

st.write('''\
オブジェクトは通常リテラルを用いて生成します．
''')

st.code('''\
>>> 'Hello World'
'Hello World'
''')

st.text('''\
---------------
|             |
|             |
| Hello World |
|             |
| type: str   |
---------------
''')

st.code('''\
>>> 1991
1991
''')

st.text('''\
---------------
|             |
|             |
|    1991     |
|             |
| type: int   |
---------------
''')

st.info('''
リテラルとは，組み込み型のオブジェクトを生成するための記法です．例えばクォーテーション`''`やダブルクォーテーション`""`で任意のunicode文字を囲むと文字列オブジェクトが生成されます．
また0以外から始まる数字を並べると整数型オブジェクトが生成されます．
''')

st.markdown('---')

st.write('''
オブジェクトの型を確認するには，組み込み関数`type()`を利用します．
''')

st.code('''\
>>> type('Hello World')
<class 'str'>
>>> type(1991)
<class 'int'>
>>> type(type)
<class 'type'>
''')

st.write('''\
また，組み込み関数`id()`はオブジェクトの識別子を返します．

''')

st.code('''
>>> id('Hello World')
4379060208
>>> id(1991)
4372760080
''')

st.write('''
識別子はオブジェクトに対して一意に割り当てられ，実行中は変更されることはありません．

加えて識別子はメモリ上でのオブジェクトの位置を表します．そのため[`ctypes.cast`](https://docs.python.org/3/library/ctypes.html#ctypes.cast)を利用して，直接取得したメモリアドレスへのアクセスすることも可能です．
''')

st.code('''\
>>> import ctypes
>>> obj = 'Hello World'
>>> ctypes.cast(id(obj), ctypes.py_object).value
'Hello World'
''')

st.info('''
Pythonでは直接的なメモリアクセスは推奨されません．上のコードを書くようなことはまずありません．
''')

st.header('2. 変数は箱ではない')

st.write('''\
特定の文脈では変数に対して「値を格納する箱」のように説明される場合がありますが，特にPythonの文脈においてこのイメージは不正確です．
''')

st.code('''\
>>> var = 1991
>>> var
1991
''')

st.text('''
----------------
|              |
|              |
|     1991     |
|              |
|  var         |
----------------
''')
st.caption('''(x)誤ったイメージ: `var`という名前の箱に`1991`という値が入っている''')

st.write('''
変数を格納する箱と表現した場合，以下のコードの説明がつきません．
''')

st.code('''
>>> a = [1, 2, 3]
>>> b = a
>>> a += [4]
>>> b
[1, 2, 3, 4]
''')

st.write('''
正しくは，**変数はオブジェクトに紐づいたタグ**のようなものです．上の例では，リストオブジェクトに対して`a`と`b`という名前のタグが紐づいていることになります．
''')

st.info('''
Python日本語ドキュメントでは，assignment statement(`=`)を代入文と訳していますが，前述の通り変数が箱であるという誤解を招きやすいため，私はこの訳語に対し否定的な立場です．
''')

st.write('''
そもそもPythonの代入文(assignment statement)では，以下で[`dis.dis`](https://docs.python.org/3/library/dis.html#dis.dis)の出力が示すとおり右辺が先に評価されます．
''')

st.code('''\
>>> import dis
>>> dis.dis('var = 1991')
    1           0 LOAD_CONST               0 (1991)
                2 STORE_NAME               0 (var)
                4 LOAD_CONST               1 (None)
                6 RETURN_VALUE
''')

st.caption('''
`dis.dis`はPythonのバイトコードへの逆コンパイルを提供し，Pythonインタプリタがソースコードをどのように解釈して実行するかを示します．詳細は省略しますが，1991が一番先に評価されていることがわかります．
''')

st.write('''
変数ありきで考えると，代入文の右辺が先に評価されることは不自然に感じられます．そうではなく，オブジェクトが先に生成され，その後に変数がオブジェクトに紐づけられると考えると自然でしょう．
''')

st.code('''\
>>> var = 1991
>>> var
1991
''')

st.text('''\
----------------
|              |
|              |
|     1991     |
|              |
| type: int    |-----[var]
----------------
''')

st.code('''
...
>>> var2 = var
>>> var2
1991
''')

st.text('''\
----------------
|              |
|              |
|     1991     |
|              |-----[var2]
| type: int    |-----[var]
----------------
''')

st.write('''
専門的な用語を用いると，変数は**オブジェクトに対する参照**です．作ったオブジェクトがメモリの波に飲み込まれれる前に，変数を通してオブジェクトへの参照を保持する，つまり繋がりを持たせることで，その後もオブジェクトを利用できるようにしているのです．
''')

st.info('例えばCやC++などのように，変数を値を格納する箱と考えるべき言語も存在します．これらの言語では変数はメモリ上の特定の位置を表します．')

st.markdown('---')

st.write('''
前節で，オブジェクトが保存されているメモリアドレスへ直接アクセスする方法を紹介しました．
''')

st.code('''\
>>> import ctypes
>>> obj = 'Hello World'
>>> id(obj)
4379060208
>>> ctypes.cast(4379060208, ctypes.py_object).value
'Hello World'
''')

st.write('''\
上記の例では`obj`という変数を利用してオブジェクトへの参照を保持していますが，以下のようにオブジェクトへの参照が保持されず，オブジェクトへ到達不可能になると，オブジェクトはガベージコレクト（後述）され，メモリから消去されます．

解放されたオブジェクトのメモリを参照しても期待される出力は得られません．
''')

st.code('''\
>>> import ctypes
>>> id('Hello World')
4379060208
>>> ctypes.cast(4379060208, ctypes.py_object).value
b'e\x00\xa0\x01e\x02e\x00j\x03\xa1\x02j\x04F\x00d\x00S\x00'
''')

st.caption(
    "2行目でリテラルを利用して'Hello World'という値をもつ文字列オブジェクトが生成されましたが，直前の例と異なり参照が保持されないため，以降このオブジェクトに対して操作することは不可能です．"
    "オブジェクトはガベージコレクトされ，メモリが解放されたため，元々の位置にあったデータは上書きされています．")

st.markdown('---')

st.header('3. ガベージコレクションと参照カウント')

st.write('''
Pythonでは，オブジェクトが不要になった時点で自動的にメモリを解放する仕組みがあります．これを**ガベージコレクション**と呼びます．

正確には，オブジェクトへ到達不可能になった時点で，そのオブジェクトはガベージコレクションの対象となります．

到達可能性の判断には，**参照カウント**という概念が利用されます．一般的に，オブジェクトへの参照が増えると参照カウントが増え，参照が減ると参照カウントが減ります．参照カウントの値が0になった時点で，そのオブジェクトはガベージコレクションの対象となるわけです．
''')

st.write('''
`sys.getrefcount`関数を利用すると，オブジェクトへの参照カウントを取得できます．
''')

st.code('''
>>> import sys
>>> obj = 'Hello World'
>>> sys.getrefcount(obj)
2
>>> obj2 = obj
>>> sys.getrefcount(obj)
3
>>> obj2 = None
>>> sys.getrefcount(obj)
2
''')

st.caption('''
コード4行目にて，文字列オブジェクト`'Hello World'`に対して新たな参照`obj2`を作成したので，参照カウントが1増えたことが確認できます．またコード6行目で`obj2`は別のオブジェクト`None`を参照するようになったため，`'Hello World'`への参照カウントは1減ることを確認してください．
''')

st.info('''
最初の`sys.getrefcount(obj)`の返り値が2であったことに驚いた方も多いでしょう．これは，sys.getrefcount()関数の引数に渡したオブジェクトへの参照が関数内部で一時的に作成されるためです．
''')

st.write('''
参照カウントが0になった時点で，オブジェクトはガベージコレクションの対象となります．実際にガベージコレクトされるタイミングは，Pythonインタプリタの実装に依存しますが，`weakref.finalize`を利用すると，オブジェクトがガベージコレクトされた時点で任意の関数を実行することができます．
''')

st.code('''
>>> import weakref
>>> obj = {1, 2, 3}
>>> weakref.finalize(obj, lambda: print('garbage collected!'))
>>> obj = None
garbage collected!
''')

st.caption('''
3行目で，集合オブジェクト`{1, 2, 3}`に対してガベージコレクト時のコールバック関数が登録されました．その後，4行目で`{1, 2, 3}`への参照を失ったことでガベージコレクトされ，コールバック関数が実行されました．
''')

st.write('''
また参照カウントのみが到達可能性の判定に使われるわけではなく，1以上の参照カウントがあってもそれが循環参照であり，どのみち到達出来ない場合はガベージコレクトの対象になります．
''')

st.code('''
>>> import weakref
>>> class A:
...     def __init__(self):
...         self.b = None
...
>>> class B:
...     def __init__(self):
...         self.a = None
...
>>> obj1 = A()
>>> obj2 = B()
>>> obj1.b = obj2
>>> obj2.a = obj1
>>> weakref.finalize(obj1, lambda: print('garbage collected!'))
>>> obj1 = obj2 = None
garbage collected!
''')

st.caption('''
`obj1 = obj2 = None`によって，変数`obj1`と`obj2`が参照するそれぞれのオブジェクト`A`,`B`への参照がなくなり，参照カウントが1減ります．ですがまだ`A`オブジェクトの`self.b`属性が`B`オブジェクトを参照しており，また`B`オブジェクトの`self.a`属性が`A`オブジェクトを参照しているため，参照カウントは0になりません．
''')

st.write('''
結果を見るに，参照カウントを有しながらもオブジェクトはガベージコレクトされました．これは，`A`オブジェクトと`B`オブジェクトが循環参照しているため，どちらも到達可能性がないと判断されたためです．
''')

# st.write('''\
# 全てのオブジェクトは，その**型によって不変性が決まります**．特に変更可能であるものはミュータブル(mutable)，変更不可能であるものはイミュータブル(immutable)と呼ばれます．

# ''')

# st.markdown('''\
# 代表的な組み込み型の不変性は次のように分類されます．

# | 変更可能(ミュータブル) | 変更不可能(イミュータブル) |
# | ---------------------- | -------------------------- |
# |                        | bool                       |
# |                        | int                        |
# |                        | float                      |
# | list                   | tuple                      |
# | set                    | frosenset                  |
# | dict                   |                            |
# ''')

# st.write('\n')

# st.write('''
# 箱の例を用いると，ミュータブルなオブジェクトは箱の蓋が空いており，反対にイミュータブルなオブジェクトは箱が閉じているような状態であると捉えることができます．
# ''')

# st.code('''
# >>> 1991
# 1991
# >>> []
# []
# ''')

# st.text('''
#                          /
#                         /
#                        /
# ----------------      /           ----
# |              |      |              |
# |              |      |              |
# |     1991     |      |      []      |
# |              |      |              |
# |              |      |              |
# | type: int    |      | type: list   |
# ----------------      ----------------
# ''')
